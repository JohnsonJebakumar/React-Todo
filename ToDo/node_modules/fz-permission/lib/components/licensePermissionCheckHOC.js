'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.urlLicensePermissionCheckHOC = exports.licensePermissionCheckHOC = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reselect = require('reselect');

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var licensePermissionCheckHOC = exports.licensePermissionCheckHOC = function licensePermissionCheckHOC(_ref) {
	var _ref$component = _ref.component,
	    component = _ref$component === undefined ? { license: "*", permission: "*" } : _ref$component,
	    _ref$props = _ref.props,
	    props = _ref$props === undefined ? {} : _ref$props,
	    _ref$Fallback = _ref.Fallback,
	    Fallback = _ref$Fallback === undefined ? null : _ref$Fallback;

	console.log(component);
	var proxyPropsObjHasFunction = Object.keys(props).some(function (key) {
		return typeof props[key] == "function";
	});
	var getLicenseProfileCheck = function getLicenseProfileCheck(componentProps, currentPermission, currentLicense) {
		var permissionCheckWithProfile = (0, _utils.permissionCheck)(currentPermission);
		var licenseSuccess = (0, _utils.licenseCheck)(currentLicense)(component.license);
		var permissionSuccess = permissionCheckWithProfile(component.permission);
		var permissionProps = Object.keys(props).reduce(function (res, next) {
			if (props[next] instanceof Array) {
				res[next] = props[next].map(function (permissionObj, i) {
					if (permissionCheckWithProfile(permissionObj.permission)) {
						return permissionObj.obj;
					}
				}).filter(function (permission) {
					return permission;
				});
				return res;
			} else if (typeof props[next] == "function") {
				permissionObj = props[next](componentProps);
				console.log("fun", permissionCheckWithProfile(permissionObj.permission));
				if (permissionCheckWithProfile(permissionObj.permission)) {
					res[next] = permissionObj.obj;
				} else if (permissionObj.falseObj) {
					res[next] = permissionObj.falseObj;
				}
				return res;
			} else {
				var permissionObj = props[next];
				if (permissionCheckWithProfile(permissionObj.permission)) {
					res[next] = permissionObj.obj;
				} else {
					res[next] = permissionObj.falseObj;
				}
				return res;
			}
		}, {});
		return { licenseSuccess: licenseSuccess, permissionSuccess: permissionSuccess, permissionProps: permissionProps };
	};

	return function (Component) {
		var HigherOrderPermission = function (_React$Component) {
			_inherits(HigherOrderPermission, _React$Component);

			function HigherOrderPermission(props, context) {
				_classCallCheck(this, HigherOrderPermission);

				var _this = _possibleConstructorReturn(this, (HigherOrderPermission.__proto__ || Object.getPrototypeOf(HigherOrderPermission)).call(this, props, context));

				_this.currentPermission = props.permission || context.permission;
				_this.currentLicense = props.license || context.license;
				return _this;
			}

			_createClass(HigherOrderPermission, [{
				key: 'render',
				value: function render() {
					var props = proxyPropsObjHasFunction ? this.props : {};

					var _getLicenseProfileChe = getLicenseProfileCheck(props, this.currentPermission, this.currentLicense),
					    licenseSuccess = _getLicenseProfileChe.licenseSuccess,
					    permissionSuccess = _getLicenseProfileChe.permissionSuccess,
					    permissionProps = _getLicenseProfileChe.permissionProps;

					console.log(permissionSuccess, licenseSuccess, permissionProps, Component);
					if (licenseSuccess && permissionSuccess) {
						return _react2.default.createElement(Component, _extends({}, this.props, permissionProps));
					} else if (Fallback) {
						return _react2.default.createElement(Fallback, this.props);
					} else {
						return null;
					}
				}
			}]);

			return HigherOrderPermission;
		}(_react2.default.Component);

		HigherOrderPermission.contextTypes = {
			store: _react2.default.PropTypes.object,
			permission: _react2.default.PropTypes.object
		};
		return HigherOrderPermission;
	};
};

var urlLicensePermissionCheckHOC = exports.urlLicensePermissionCheckHOC = function urlLicensePermissionCheckHOC(ob) {
	ob.Fallback = InsufficientPrivileges;
	return licensePermissionCheckHOC(ob);
};